<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Gemini Interview Helper</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      background: rgba(26, 26, 26, 0.85);
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      position: relative;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    /* Instruction banner styling */
    #instruction-banner {
      display: none;
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 8px 15px;
      font-size: 14px;
      border-radius: 0 0 8px 8px;
      z-index: 9999;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transition: opacity 0.3s ease;
      user-select: none;
    }
    
    #chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      position: fixed;
      top: 0;
      left: 0;
      padding: 20px;
      box-sizing: border-box;
    }

    .chat-message {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 12px;
      font-size: 13px;
      max-width: 100%;
      word-wrap: break-word;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    .user-message {
      background: rgba(51, 51, 51, 0.85);
      color: #fff;
      margin-left: auto;
      margin-right: 0;
    }

    .model-response {
      background: rgba(68, 68, 68, 0.85);
      color: #fff;
      margin-left: 0;
      margin-right: auto;
      backdrop-filter: blur(5px);
    }

    .help-message {
      background: rgba(44, 62, 80, 0.95);
      color: #fff;
      width: 100%;
      font-weight: bold;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .user-message img {
      max-width: 100%;
      border-radius: 4px;
      margin-top: 10px;
    }
    
    #progress-bar {
      width: 100%;
      height: 3px;
      background: rgba(85, 85, 85, 0.5);
      margin-top: 10px;
      border-radius: 2px;
      display: none;
    }

    #progress-bar-inner {
      width: 50%;
      height: 100%;
      background: rgba(119, 119, 119, 0.8);
      animation: progress-animation 2s infinite;
      border-radius: 2px;
    }

    @keyframes progress-animation {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(200%); }
    }
    
    #response-overlay {
      position: fixed;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.85);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s;
      z-index: 9998;
      backdrop-filter: blur(3px);
    }
    
    #response-overlay.visible {
      opacity: 1;
      visibility: visible;
    }
    
    #response-box {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      background: rgba(25,25,25,0.95);
      color: #fff;
      padding: 25px;
      box-sizing: border-box;
      font-size: 15px;
      line-height: 1.5;
      border-radius: 8px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    #response-box::-webkit-scrollbar {
      width: 8px;
    }
    
    #response-box::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
    #response-box::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
      border-radius: 4px;
    }
    
    pre {
      background: rgba(40,40,40,0.95);
      color: #f0f0f0;
      padding: 15px;
      border-radius: 6px;
      white-space: pre;
      overflow-x: auto;
      margin: 1em 0;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    code {
      font-family: 'Fira Code', Consolas, 'Courier New', monospace;
      background: rgba(60,60,60,0.95);
      color: #fff;
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    #response-box p {
      margin: 0 0 10px 0;
    }
    
    #response-box p:last-child {
      margin-bottom: 0;
    }
    
    .error-message {
      color: #ff4444;
      background: rgba(255,68,68,0.1);
      padding: 15px;
      border-radius: 6px;
      border-left: 4px solid #ff4444;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div id="instruction-banner"></div>
  <div id="chat-container">
    <div id="chat-messages" style="overflow-y: auto; max-height: calc(100vh - 100px);"></div>
    <div id="progress-bar"><div id="progress-bar-inner"></div></div>
  </div>
  <div id="response-overlay">
    <div id="response-box"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    const { ipcRenderer } = require('electron');
    
    marked.setOptions({
      sanitize: true,
      breaks: true,
      gfm: true
    });

    const chatContainer = document.getElementById('chat-container');
    const chatMessages = document.getElementById('chat-messages');
    const progressBar = document.getElementById('progress-bar');
    
    const showOverlay = () => {
      const overlay = document.getElementById('response-overlay');
      overlay.classList.add('visible');
    };
    
    const hideOverlay = () => {
      const overlay = document.getElementById('response-overlay');
      overlay.classList.remove('visible');
    };
    
    const updateBanner = (text, show = true) => {
      const banner = document.getElementById('instruction-banner');
      banner.style.opacity = show ? '1' : '0';
      if (text) banner.textContent = text;
    };

    const showChat = () => {
      // Chat is always visible now
    }

    const hideChat = () => {
      chatMessages.innerHTML = '';
    }

    const showProgressBar = () => {
      progressBar.style.display = 'block';
    }

    const hideProgressBar = () => {
      progressBar.style.display = 'none';
    }

    const addMessage = (message, type, image) => {
      const messageElement = document.createElement('div');
      messageElement.classList.add('chat-message', type);
      messageElement.innerHTML = marked.parse(message);
      if (image) {
        const imageElement = document.createElement('img');
        imageElement.src = `data:image/png;base64,${image}`;
        messageElement.appendChild(imageElement);
      }
      chatMessages.appendChild(messageElement);
    }
    
    const handlers = {
      'analysis-result': (event, result) => {
        hideProgressBar();
        addMessage(result, 'model-response');
        updateBanner("Ctrl+Shift+R: Repeat process | Ctrl+Shift+W: Hide Window | Ctrl+Shift+W: Close");
      },
      'store-response': (event, result) => {
        // Store the AI response in the overlay for persistence when hiding/showing
        const responseBox = document.getElementById('response-box');
        responseBox.innerHTML = marked.parse(result);
      },
      'show-chat': (event, {prompt, image}) => {
        showChat();
        addMessage(prompt, 'user-message', image);
        showProgressBar();
      },
      'show-help': (event, helpText) => {
        showChat();
        addMessage(helpText, 'help-message');
        updateBanner('', false);
      },
      'error': (event, error) => {
        hideProgressBar();
        showOverlay();
        document.getElementById('response-box').innerHTML = 
          `<div class="error-message">
            <strong>Error:</strong> ${error}
            <br><small>Press Ctrl+Shift+R to try again</small>
          </div>`;
      },
      
      'update-instruction': (event, instruction) => {
        updateBanner(instruction, true);
      },
      
      'hide-instruction': () => {
        updateBanner('', false);
      },

      'hide-app': () => {
        updateBanner('', false);
        hideOverlay();
        // Don't clear chat - preserve conversation history
      },

      'show-app': () => {
        updateBanner("Ctrl+Shift+R: Repeat process | Ctrl+Shift+W: Hide Window | Ctrl+Shift+Q: Close", true);
        showOverlay();
        // Chat messages are preserved and will be visible when overlay shows
      },
      
      'clear-result': () => {
        document.getElementById('response-box').innerHTML = "";
        chatMessages.innerHTML = "";
        hideOverlay();
        hideChat();
      }
    };
    
    Object.entries(handlers).forEach(([channel, handler]) => {
      ipcRenderer.on(channel, handler);
    });
    
    // Handle window capture requests from main process
    ipcRenderer.on('capture-window', async (event, sourceId) => {
      try {
        console.log('Renderer: Received capture request for source:', sourceId);
        
        // Check if getUserMedia is available
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          throw new Error('getUserMedia not supported');
        }
        
        console.log('Renderer: Attempting to get media stream...');
        
        // Get user media stream using the provided source ID
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              minWidth: 1280,
              maxWidth: 4000,
              minHeight: 720,
              maxHeight: 4000
            }
          }
        });
        
        console.log('Renderer: Successfully got media stream:', stream);
        
        // Create video element to capture frame
        const video = document.createElement('video');
        video.srcObject = stream;
        video.style.display = 'none';
        document.body.appendChild(video);
        
        video.onloadedmetadata = () => {
          video.play();
          
          // Wait a bit for video to start
          setTimeout(() => {
            try {
              // Create canvas and capture frame
              const canvas = document.createElement('canvas');
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              
              const ctx = canvas.getContext('2d');
              ctx.drawImage(video, 0, 0);
              
              // Stop the stream
              stream.getTracks().forEach(track => track.stop());
              
              // Remove video element
              document.body.removeChild(video);
              
              // Convert to base64
              const base64 = canvas.toDataURL('image/png').split(',')[1];
              
              console.log('Renderer: Successfully captured frame');
              
              // Send result back to main process
              ipcRenderer.send('capture-result', base64);
              
            } catch (captureError) {
              console.error('Renderer: Frame capture error:', captureError);
              stream.getTracks().forEach(track => track.stop());
              if (document.body.contains(video)) {
                document.body.removeChild(video);
              }
              ipcRenderer.send('capture-error', captureError.message);
            }
          }, 100);
        };
        
        video.onerror = (error) => {
          console.error('Renderer: Video error:', error);
          stream.getTracks().forEach(track => track.stop());
          if (document.body.contains(video)) {
            document.body.removeChild(video);
          }
          ipcRenderer.send('capture-error', 'Video playback failed');
        };
        
      } catch (error) {
        console.error('Renderer: Capture error:', error);
        
        // Provide more specific error messages based on the error type
        let errorMessage = error.message;
        
        if (error.name === 'NotAllowedError') {
          errorMessage = 'Screen recording permission denied. Please grant screen recording permission to this app in System Preferences > Security & Privacy > Privacy > Screen Recording';
        } else if (error.name === 'NotFoundError') {
          errorMessage = 'No screen capture source found. The window may have been closed or minimized.';
        } else if (error.name === 'NotSupportedError') {
          errorMessage = 'Screen capture not supported on this system.';
        } else if (error.message.includes('Could not start video source')) {
          errorMessage = 'Could not start video source. This usually means screen recording permissions are not granted. Please check System Preferences > Security & Privacy > Privacy > Screen Recording and ensure this app is enabled.';
        }
        
        ipcRenderer.send('capture-error', errorMessage);
      }
    });
    
    window.addEventListener('unload', () => {
      Object.keys(handlers).forEach(channel => {
        ipcRenderer.removeAllListeners(channel);
      });
      ipcRenderer.removeAllListeners('capture-window');
    });
    
    updateBanner("Ctrl+Shift+S: Screenshot | Ctrl+Shift+A: Multi-mode | Ctrl+Shift+W: Hide Window | Ctrl+Shift+Q: Close");
  </script>
</body>
</html>
